package main

import (
	"bytes"
	"github.com/juju/charm/v9"
	"go/build"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"

	"gopkg.in/errgo.v1"
	"gopkg.in/yaml.v2"
)

const (
	hookPackage    = "github.com/mever/gocharm/v2/hook"
	autogenMessage = `This file is automatically generated. Do not edit.`
)

var hookMainCode = template.Must(template.New("").Parse(`
// {{.AutogenMessage}}

package main

import (
	"fmt"
	"os"
	charm {{.CharmPackage | printf "%q"}}
	{{.HookPackage | printf "%q"}}
)

func main() {
	r := hook.NewRegistry()
	charm.RegisterHooks(r)
	hook.RegisterMainHooks(r)
	if len(os.Args) < 2 {
		fatalf("hook name argument required")
	}
	// TODO would /etc/init be a better place for local state?
	ctxt, state, err := hook.NewContextFromEnvironment(r, "/var/lib/juju-localstate", os.Args[1], os.Args[2:])
	if err != nil {
		fatalf("cannot create context: %v", err)
	}
	defer ctxt.Close()
	cmd, err := hook.Main(r, ctxt, state)
	if err != nil {
		fatalf("%v", err)
	}
	if cmd == nil {
		return
	}
	if err := cmd.Wait(); err != nil {
		fatalf("%v", err)
	}
}

func fatalf(f string, a ...interface{}) {
	fmt.Fprintf(os.Stderr, "runhook: %s\n", fmt.Sprintf(f, a...))
	os.Exit(1)
}
`))

type buildCharmParams struct {
	// pkg specifies the package that the hook will be built from.
	pkg *build.Package

	// charmDir specifies the destination directory to write
	// the charm files to.
	charmDir string

	// tempDir holds a temporary directory to use for
	// any temporary build artifacts.
	tempDir string
}

type charmBuilder buildCharmParams

func getGoModuleNameFromCurrentDir() string {
	cmd := runCmd("", nil, "go", "list", "-m")
	cmd.Stdout = nil
	data, er := cmd.Output()
	if er != nil {
		panic("failed to get Go module name")
	}
	return strings.SplitN(string(data), "\n", 2)[0]
}

func prepareTempSource(goFile, exeFile, modulePath, importPath string) ([]string, error) {
	code := generateCode(hookMainCode, importPath)
	if err := os.MkdirAll(filepath.Dir(goFile), 0777); err != nil {
		return nil, errgo.Mask(err)
	}
	if err := os.MkdirAll(filepath.Dir(exeFile), 0777); err != nil {
		return nil, errgo.Mask(err)
	}
	if err := ioutil.WriteFile(goFile, code, 0666); err != nil {
		return nil, errgo.Mask(err)
	}
	env := os.Environ()
	env = setenv(env, "CGOENABLED=false")
	env = setenv(env, "GOARCH=amd64")
	env = setenv(env, "GOOS=linux")

	goDir := filepath.Dir(goFile)
	if *verbose {
		log.Printf("building in: %s", goDir)
	}
	if err := runCmd(goDir, env, "go", "mod", "init", "github.com/mever/gocharm/tmp-build").Run(); err != nil {
		return nil, errgo.Notef(err, "failed to initialize Go modules")
	}

	localPath, er := os.Getwd()
	if er != nil {
		return nil, errgo.Notef(er, "can not get current directory")
	}

	localModulePath := getLocalPathToGoModule(modulePath, importPath, localPath)
	if err := runCmd(goDir, env, "go", "mod", "edit", "-replace", modulePath+"="+localModulePath).Run(); err != nil {
		return nil, errgo.Notef(err, "failed to replace package path with a local path")
	}

	if err := runCmd(goDir, env, "go", "mod", "tidy").Run(); err != nil {
		return nil, errgo.Notef(err, "failed to tidy Go modules")
	}
	return env, nil
}

func getLocalPathToGoModule(modulePath, importPath, localPath string) string {
	if modulePath == importPath {
		return localPath
	} else {
		return localPath[0:len(localPath)-len(importPath[len(modulePath):])]
	}
}

// buildCharm builds the runhook executable,
// and all the other charm pieces (hooks, metadata.yaml,
// config.yaml). It puts the runhook source file into goFile
// and the runhook executable into exe.
func buildCharm(p buildCharmParams) error {
	b := (*charmBuilder)(&p)

	modulePath := getGoModuleNameFromCurrentDir()
	importPath := b.pkg.ImportPath
	if importPath == "." {
		importPath = modulePath
	}

	exeFile := filepath.Join(b.charmDir, "bin", "runhook")
	goFile := filepath.Join(b.charmDir, "src", "runhook", "runhook.go")
	env, err := prepareTempSource(goFile, exeFile, modulePath, importPath)
	if err != nil {
		return errgo.Notef(err, "cannot build hooks main package")
	}

	if err := compile(goFile, exeFile, env); err != nil {
		return errgo.Notef(err, "cannot build hooks main package")
	}
	if _, err := os.Stat(exeFile); err != nil {
		return errgo.New("runhook command not built")
	}

	info, err := registeredCharmInfo(importPath, p.tempDir)
	if err != nil {
		return errgo.Mask(err)
	}
	if err := b.writeHooks(info.Hooks); err != nil {
		return errgo.Notef(err, "cannot write hooks to charm")
	}
	if err := b.writeMeta(info.Meta); err != nil {
		return errgo.Notef(err, "cannot write metadata.yaml")
	}
	if err := b.writeConfig(info.Config); err != nil {
		return errgo.Notef(err, "cannot write config.yaml")
	}
	// Sanity check that the new config files parse correctly.
	_, err = charm.ReadCharmDir(b.charmDir)
	if err != nil {
		return errgo.Notef(err, "charm will not read correctly; we've broken it, sorry")
	}
	return nil
}

// writeHooks ensures that the charm has the given set of hooks.
// TODO write install and start hooks even if they're not registered,
// because otherwise it won't be treated as a valid charm.
func (b *charmBuilder) writeHooks(hooks []string) error {
	if *verbose {
		log.Printf("writing hooks in %s", b.charmDir)
	}
	hookDir := filepath.Join(b.charmDir, "hooks")
	if err := os.MkdirAll(hookDir, 0777); err != nil {
		return errgo.Notef(err, "failed to make hooks directory")
	}
	infos, err := ioutil.ReadDir(hookDir)
	if err != nil {
		return errgo.Mask(err)
	}
	if *verbose {
		log.Printf("found %d existing hooks", len(infos))
	}
	// Add any new hooks we need to the charm directory.
	for _, hookName := range hooks {
		hookPath := filepath.Join(hookDir, hookName)
		if *verbose {
			log.Printf("creating hook %s", hookPath)
		}
		if err := ioutil.WriteFile(hookPath, b.hookStub(hookName), 0755); err != nil {
			return errgo.Mask(err)
		}
	}
	return nil
}

// hookStubTemplate holds the template for the generated hook code.
var hookStubTemplate = template.Must(template.New("").Parse(`#!/bin/sh
set -ex
$CHARM_DIR/bin/runhook {{.HookName}}
`))

type hookStubParams struct {
	HookName  string
}

func (b *charmBuilder) hookStub(hookName string) []byte {
	return executeTemplate(hookStubTemplate, hookStubParams{
		HookName:  hookName,
	})
}

func (b *charmBuilder) writeMeta(meta charm.Meta) error {
	// The metadata name must match the directory name otherwise
	// juju deploy will ignore the charm.
	meta.Name = filepath.Base(b.pkg.Dir)
	if err := writeYAML(filepath.Join(b.charmDir, "metadata.yaml"), meta); err != nil {
		return errgo.Notef(err, "cannot write metadata.yaml")
	}
	return nil
}

const yamlAutogenComment = "# " + autogenMessage + "\n"

func writeYAML(file string, val interface{}) error {
	data, err := yaml.Marshal(val)
	if err != nil {
		return errgo.Notef(err, "cannot marshal YAML")
	}



	data = append([]byte(yamlAutogenComment), data...)
	if err := ioutil.WriteFile(file, data, 0666); err != nil {
		return errgo.Mask(err)
	}
	return nil
}

func (b *charmBuilder) writeConfig(config map[string]charm.Option) error {
	configPath := filepath.Join(b.charmDir, "config.yaml")
	if len(config) == 0 {
		return nil
	}
	if err := writeYAML(configPath, &charm.Config{
		Options: config,
	}); err != nil {
		return errgo.Notef(err, "cannot write config.yaml")
	}
	return nil
}

func setenv(env []string, entry string) []string {
	i := strings.Index(entry, "=")
	if i == -1 {
		panic("no = in environment entry")
	}
	prefix := entry[0 : i+1]
	for i, e := range env {
		if strings.HasPrefix(e, prefix) {
			env[i] = entry
			return env
		}
	}
	return append(env, entry)
}

type templateParams struct {
	AutogenMessage string
	CharmPackage   string
	HookPackage    string
}

func generateCode(tmpl *template.Template, charmPackage string) []byte {
	return executeTemplate(tmpl, templateParams{
		CharmPackage:   charmPackage,
		HookPackage:    hookPackage,
		AutogenMessage: autogenMessage,
	})
}

func compile(goFile, exeFile string, env []string) error {
	if err := runCmd("", env, "go", "build", "-o", exeFile, goFile).Run(); err != nil {
		return errgo.Notef(err, "failed to build")
	}
	return nil
}

func runCmd(dir string, env []string, cmd string, args ...string) *exec.Cmd {
	if *verbose {
		log.Printf("run %s %s", cmd, strings.Join(args, " "))
	}
	c := exec.Command(cmd, args...)
	if *verbose {
		c.Stdout = os.Stdout
		c.Stderr = os.Stderr
	}
	c.Env = env
	c.Dir = dir
	return c
}

func executeTemplate(t *template.Template, param interface{}) []byte {
	var w bytes.Buffer
	if err := t.Execute(&w, param); err != nil {
		panic(err)
	}
	return w.Bytes()
}
