// Package hooktest contains utilities for testing gocharm hooks.
package hooktest

import (
	"encoding/json"
	"strings"

	"gopkg.in/errgo.v1"

	"github.com/mever/gocharm/v2/hook"
)

// Find out which commands will be generated by which Context methods.

// Runner is implementation of hook.Runner suitable for use in tests.
// It calls the given RunFunc function whenever the Run method
// and records all the calls in the Record field, with the
// exception of the calls mentioned below.
//
// Any calls to juju-log are logged using Logger, but otherwise ignored.
// Calls to config-get from the Config field and not invoked through RunFunc.
// Likewise, calls to unit-get will be satisfied from the PublicAddress
// and PrivateAddress fields.
type Runner struct {
	RegisterHooks func(r *hook.Registry)

	// The following fields hold information that will
	// be available through the hook context.
	Relations   map[hook.RelationId]map[hook.UnitId]map[string]string
	RelationIds map[string][]hook.RelationId
	Config      map[string]interface{}

	PublicAddress  string
	PrivateAddress string

	// HookStateDir holds the directory in which state
	// other than hook state will be stored (for instance,
	// this is used by the service package to store service
	// logs). If this is empty, RunHook will panic.
	HookStateDir string

	// State holds the persistent state.
	// If it is nil, it will be set to a hooktest.MemState
	// instance.
	State hook.PersistentState

	// RunFunc is called when a hook tool runs.
	// It may be nil, in which case it will be assumed
	// that the hook tool runs successfully with no output.
	RunFunc func(string, ...string) ([]byte, error)
	Record  [][]string

	// Logger should be set to a logger. The Logf method
	// will be called when the charm generates log messages.
	Logger interface {
		Logf(string, ...interface{})
	}

	// Close records whether the Close method has been called.
	Closed bool
}

// RunHook runs a hook in the context of the Runner. If it's a relation
// hook, then relId should hold the current relation id and
// relUnit should hold the unit that the relation hook is running for.
//
// Any hook tools that have been run will be stored in r.Record.
func (runner *Runner) RunHook(hookName string, relId hook.RelationId, relUnit hook.UnitId) error {
	if runner.HookStateDir == "" {
		panic("empty hook state dir")
	}
	if runner.State == nil {
		runner.State = make(MemState)
	}
	r := hook.NewRegistry()
	runner.RegisterHooks(r)
	hook.RegisterMainHooks(r)
	hctxt := &hook.Context{
		UUID:         UUID,
		Unit:         "someunit/0",
		CharmDir:     "/dev/null",
		HookStateDir: runner.HookStateDir,

		HookName:    hookName,
		Runner:      runner,
		Relations:   runner.Relations,
		RelationIds: runner.RelationIds,
	}
	if relId != "" {
		hctxt.RelationId = relId
		hctxt.RemoteUnit = relUnit
	loop:
		for name, ids := range runner.RelationIds {
			for _, id := range ids {
				if id == hctxt.RelationId {
					hctxt.RelationName = name
					break loop
				}
			}
		}
		if hctxt.RelationName == "" {
			panic("relation id not found")
		}
	}
	c, err := hook.Main(r, hctxt, runner.State)
	if c != nil {
		panic(errgo.Newf("non-command hook returned Command"))
	}
	return err
}

// RunCommand runs the given command in the context of the Runner.
// The cmdName should be a name returned by hook.Context.CommandName.
func (runner *Runner) RunCommand(cmdName string, args []string) (hook.Command, error) {
	if !strings.HasPrefix(cmdName, "cmd-") {
		panic(errgo.Newf(`command name %q does not have "cmd-" prefix`, cmdName))
	}
	r := hook.NewRegistry()
	runner.RegisterHooks(r)
	hook.RegisterMainHooks(r)
	hctxt := &hook.Context{
		RunCommandName: strings.TrimPrefix(cmdName, "cmd-"),
		RunCommandArgs: args,
	}
	return hook.Main(r, hctxt, nil)
}

// Run implements hook.Runner.Run.
func (runner *Runner) Run(cmd string, args ...string) ([]byte, error) {
	if cmd == "juju-log" {
		if len(args) != 1 {
			panic("expected exactly one argument to juju-log")
		}
		runner.Logger.Logf("%s", args[0])
		return nil, nil
	}
	switch cmd {
	case "config-get":
		var val interface{}
		if len(args) < 4 {
			// config-get --format json
			val = runner.Config
		} else {
			// config-get --format json -- key
			key := args[3]
			val = runner.Config[key]
		}
		data, err := json.Marshal(val)
		if err != nil {
			panic(err)
		}
		return data, nil
	case "unit-get":
		if len(args) != 1 {
			panic("expected exactly one argument to unit-get")
		}
		switch args[0] {
		case "public-address":
			return []byte(runner.PublicAddress), nil
		case "private-address":
			return []byte(runner.PrivateAddress), nil
		default:
			panic("unexpected argument to unit-get")
		}
	}
	rec := []string{cmd}
	rec = append(rec, args...)
	runner.Record = append(runner.Record, rec)
	if runner.RunFunc != nil {
		return runner.RunFunc(cmd, args...)
	}
	return nil, nil
}

// Run implements hook.Runner.Close.
// It panics if called more than once.
func (runner *Runner) Close() error {
	if runner.Closed {
		panic("runner closed twice")
	}
	runner.Closed = true
	return nil
}

// MemState implements hook.PersistentState in memory.
// Each element of the map holds the value key stored in the state.
type MemState map[string][]byte

func (s MemState) Save(name string, data []byte) error {
	s[name] = data
	return nil
}

func (s MemState) Load(name string) ([]byte, error) {
	return s[name], nil
}

// UUID holds an arbitrary environment UUID for testing purposes.
const UUID = "373b309b-4a86-4f13-88e2-c213d97075b8"
